#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
from pathlib import Path

# Configuration
PROJECT_ROOT = Path(__file__).parent.parent.resolve()
VENV_DIR = PROJECT_ROOT / ".trellis" / "virtualenv"
VAULT_PASS_FILE = PROJECT_ROOT / ".vault_pass"

def get_venv_python():
    """Returns the path to the virtualenv python executable."""
    if os.name == "nt":
        return VENV_DIR / "Scripts" / "python.exe"
    return VENV_DIR / "bin" / "python"

def ensure_venv():
    """Ensures the script is running within the project's virtual environment."""
    venv_python = get_venv_python()
    
    # If we are already running from the venv, we're good
    if sys.executable == str(venv_python):
        return

    # If the venv exists, re-execute the script using the venv python
    if venv_python.exists():
        os.environ["PATH"] = f"{venv_python.parent}{os.pathsep}{os.environ.get('PATH', '')}"
        os.environ["VIRTUAL_ENV"] = str(VENV_DIR)
        os.execv(str(venv_python), [str(venv_python)] + sys.argv)
    else:
        print(f"‚ùå Error: Virtual environment not found at {VENV_DIR}")
        print("   Please run './bin/setup.sh' first.")
        sys.exit(1)

def run_command(cmd, cwd=PROJECT_ROOT):
    """Runs a shell command and exits on failure."""
    try:
        # Use shell=True for complex commands or let subprocess handle the list
        if isinstance(cmd, list):
            print(f"üöÄ Running: {' '.join(cmd)}\n")
            result = subprocess.run(cmd, cwd=cwd)
        else:
            print(f"üöÄ Running: {cmd}\n")
            result = subprocess.run(cmd, shell=True, cwd=cwd)
        
        if result.returncode != 0:
            sys.exit(result.returncode)
    except KeyboardInterrupt:
        print("\n\nüö´ Interrupted by user.")
        sys.exit(1)

def get_environments():
    """Returns a list of available environments from the hosts directory."""
    hosts_dir = PROJECT_ROOT / "hosts"
    if not hosts_dir.exists():
        return []
    return [f.name for f in hosts_dir.iterdir() if f.is_file() and not f.name.startswith('.')]

def get_sites(environment):
    """Reads the wordpress_sites.yml file and returns a list of site keys."""
    # We import yaml here because this function is called AFTER ensure_venv
    import yaml
    
    sites_file = PROJECT_ROOT / "group_vars" / environment / "wordpress_sites.yml"
    if not sites_file.exists():
        return []
    
    try:
        with open(sites_file, 'r') as f:
            data = yaml.safe_load(f)
            if data and 'wordpress_sites' in data:
                return list(data['wordpress_sites'].keys())
    except Exception as e:
        print(f"‚ö†Ô∏è  Warning: Could not parse sites file: {e}")
    return []

def get_vault_args():
    """Returns the vault password file argument if the file exists."""
    if VAULT_PASS_FILE.exists():
        return ["--vault-password-file", str(VAULT_PASS_FILE)]
    return []

def confirm(message):
    """Prompts the user for confirmation."""
    print(f"‚ö†Ô∏è  {message}")
    try:
        reply = input("   Are you sure you want to continue? [y/N] ").lower()
        if reply != 'y':
            print("üö´ Aborted.")
            sys.exit(1)
    except EOFError:
        sys.exit(1)

def handle_deploy(args, extra):
    """Handles the 'deploy' subcommand."""
    if args.environment not in get_environments():
        print(f"‚ùå Error: '{args.environment}' is not a valid environment.")
        print(f"   Available: {', '.join(get_environments())}")
        sys.exit(1)

    site = args.site
    available_sites = get_sites(args.environment)

    if not site:
        if len(available_sites) == 1:
            site = available_sites[0]
            print(f"‚ú® Auto-detected site: {site}")
        elif len(available_sites) > 1:
            print(f"‚ùå Error: Multiple sites found in '{args.environment}'. Please specify one.")
            print(f"   Available sites: {', '.join(available_sites)}")
            sys.exit(1)
        else:
            print(f"‚ùå Error: No sites found in '{args.environment}' configuration.")
            sys.exit(1)
    elif site not in available_sites:
         print(f"‚ö†Ô∏è  Warning: Site '{site}' not found in configuration for '{args.environment}'.")
         print(f"   Available sites: {', '.join(available_sites) if available_sites else 'None'}")
         confirm("Do you want to proceed anyway?")

    confirm(f"You are about to deploy '{site}' to '{args.environment}'.")
    
    cmd = [
        "ansible-playbook", "deploy.yml",
        "-e", f"env={args.environment}",
        "-e", f"site={site}"
    ] + get_vault_args() + extra
    run_command(cmd)

def handle_provision(args, extra):
    """Handles the 'provision' subcommand."""
    if args.environment not in get_environments():
        print(f"‚ùå Error: '{args.environment}' is not a valid environment.")
        print(f"   Available: {', '.join(get_environments())}")
        sys.exit(1)

    confirm(f"You are about to PROVISION the '{args.environment}' environment.")
    
    cmd = [
        "ansible-playbook", "server.yml",
        "-e", f"env={args.environment}"
    ] + get_vault_args() + extra
    run_command(cmd)

def handle_vault(args, extra):
    """Handles the 'vault' subcommand."""
    command = args.vault_command
    group_vars_dir = PROJECT_ROOT / "group_vars"
    
    files = list(group_vars_dir.glob("**/vault.yml"))
    if not files:
        print(f"‚ö†Ô∏è  No 'vault.yml' files found in {group_vars_dir}")
        return

    target_files = []
    if command == "decrypt":
        for f in files:
            with open(f, 'r') as file_content:
                if "$ANSIBLE_VAULT" in file_content.readline():
                    target_files.append(str(f))
                else:
                    print(f"‚ÑπÔ∏è  Skipping already decrypted file: {f.relative_to(PROJECT_ROOT)}")
    elif command == "encrypt":
        for f in files:
            with open(f, 'r') as file_content:
                if "$ANSIBLE_VAULT" not in file_content.readline():
                    target_files.append(str(f))
                else:
                    print(f"‚ÑπÔ∏è  Skipping already encrypted file: {f.relative_to(PROJECT_ROOT)}")
    else:
        target_files = [str(f) for f in files]

    if not target_files:
        print(f"‚úÖ No files require action for '{command}'.")
        return

    cmd = ["ansible-vault", command] + get_vault_args() + target_files + extra
    run_command(cmd)

def main():
    parser = argparse.ArgumentParser(description="Trellis Management Tool")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # Deploy
    deploy_parser = subparsers.add_parser("deploy", help="Deploy a site to an environment")
    deploy_parser.add_argument("environment", help="Target environment (staging, production, etc.)")
    deploy_parser.add_argument("site", nargs='?', help="WordPress site name (optional if only one site exists)")

    # Provision
    provision_parser = subparsers.add_parser("provision", help="Provision a server environment")
    provision_parser.add_argument("environment", help="Target environment (staging, production, etc.)")

    # Vault
    vault_parser = subparsers.add_parser("vault", help="Manage Ansible Vault files")
    vault_parser.add_argument("vault_command", help="Vault command (encrypt, decrypt, view, edit, etc.)")

    # Parse known args and capture the rest for ansible-playbook/vault
    args, extra = parser.parse_known_args()

    # Ensure we are in the virtualenv
    ensure_venv()

    if args.command == "deploy":
        handle_deploy(args, extra)
    elif args.command == "provision":
        handle_provision(args, extra)
    elif args.command == "vault":
        handle_vault(args, extra)

if __name__ == "__main__":
    main()