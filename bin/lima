#!/usr/bin/env python3

import os
import sys
import subprocess
import re
import argparse
import tempfile
import shlex
import shutil
import json
import difflib
from pathlib import Path

# --- Setup & Bootstrap ---

BIN_DIR = Path(__file__).parent.resolve()
TRELLIS_DIR = BIN_DIR.parent
VENV_PYTHON = TRELLIS_DIR / ".trellis" / "virtualenv" / "bin" / "python"
PROVISION_MARKER = TRELLIS_DIR / ".trellis" / "provisioned"

def bootstrap_env():
    """Re-executes script inside Trellis virtualenv if yaml is missing."""
    try:
        import yaml
    except ImportError:
        if VENV_PYTHON.exists():
            os.execv(str(VENV_PYTHON), [str(VENV_PYTHON)] + sys.argv)
        sys.exit("Error: PyYAML not found. Run `./bin/setup.sh` first.")

bootstrap_env()
import yaml

# --- Manager Class ---

class TrellisLima:
    def __init__(self):
        self._check_dep("limactl")
        self.conf = self._load_config()
        self.vm_name = self.conf['canonical']

    def _check_dep(self, cmd):
        if not shutil.which(cmd): sys.exit(f"Error: '{cmd}' not installed.")

    def _run(self, cmd, capture=False, env=None, check=True):
        """Internal wrapper for subprocess.run."""
        if not capture: print(f"→ {shlex.join(str(c) for c in cmd)}")
        try:
            return subprocess.run(
                cmd, check=check, text=True, capture_output=capture,
                cwd=TRELLIS_DIR, env=env or os.environ
            )
        except subprocess.CalledProcessError as e:
            if not capture: print(f"\n[!] Failed (Exit {e.returncode}): {e.stderr}")
            sys.exit(e.returncode)

    def _load_config(self):
        """Loads site config, resolves IP, and validates paths."""
        site_yml = TRELLIS_DIR / "group_vars" / "development" / "wordpress_sites.yml"
        if not site_yml.exists(): sys.exit(f"Missing: {site_yml}")

        with open(site_yml) as f: sites = yaml.safe_load(f).get('wordpress_sites', {})
        if not sites: sys.exit("No sites in wordpress_sites.yml")

        key, data = next(iter(sites.items()))
        hosts = [h['canonical'] for h in data.get('site_hosts', [])]

        # Resolve IP from hosts file
        ip = "127.0.0.1"
        hosts_file = TRELLIS_DIR / "hosts" / "development"
        if hosts_file.exists():
            match = re.search(r"^([0-9.]+)", hosts_file.read_text(), re.MULTILINE)
            if match: ip = match.group(1)

        # Resolve and Validate Path
        local_path = (TRELLIS_DIR / data.get('local_path', '../site')).resolve()
        if not local_path.exists():
            print(f"\n\033[91m[!] Error: Local site path does not exist:\033[0m")
            print(f"    {local_path}")
            print(f"    Check 'local_path' in your development/wordpress_sites.yml\n")
            sys.exit(1)

        return {
            'key': key, 'canonical': hosts[0], 'hosts': hosts, 'ip': ip,
            'path': local_path
        }

    def _get_status(self):
        """Returns 'Running', 'Stopped', or None."""
        res = self._run(["limactl", "list", self.vm_name, "--json"], capture=True, check=False)
        if res.returncode == 0 and res.stdout.strip():
            try:
                for line in res.stdout.splitlines():
                    info = json.loads(line)
                    if info.get("name") == self.vm_name:
                        return info.get("status")
            except json.JSONDecodeError:
                pass
        return None

    def _get_ssh(self):
        """Parses connection details using `limactl list --json`."""
        res = self._run(["limactl", "list", self.vm_name, "--json"], capture=True, check=False)

        if res.returncode == 0 and res.stdout.strip():
            try:
                data = json.loads(res.stdout.splitlines()[0])
                port = data.get("sshLocalPort")
                if port and port != 0:
                    return {
                        'user': os.environ.get("USER"),
                        'key': str(Path.home() / ".lima" / "_config" / "user"),
                        'port': str(port)
                    }
            except (json.JSONDecodeError, IndexError):
                pass
        sys.exit("Error: Could not determine SSH port. Is the VM running?")

    def _check_provision_status(self):
        """Checks if provisioned and prints warning if not."""
        if not PROVISION_MARKER.exists():
            print(f"\n\033[93m[!] Warning: Server is running but has not been provisioned.\033[0m")
            print(f"    Run `init` or `provision` to complete setup.\n")

    def _build_config_data(self):
        """Generates the intended YAML config object."""
        lima_cfg = TRELLIS_DIR / "lima.yaml"
        if not lima_cfg.exists(): sys.exit("lima.yaml missing")

        with open(lima_cfg) as f: cfg = yaml.safe_load(f)

        cfg.setdefault('mounts', []).extend([
            {'location': str(TRELLIS_DIR), 'writable': True},
            {'location': str(self.conf['path']), 'mountPoint': f"/srv/www/{self.conf['key']}/current", 'writable': True}
        ])

        if 'portForwards' in cfg:
            for pf in cfg['portForwards']:
                if 'hostIP' in pf:
                    pf['hostIP'] = self.conf['ip']
        return cfg

    def _reconcile_config(self):
        """Checks actual VM config vs project config. Returns True if updated."""
        dest = Path.home() / ".lima" / self.vm_name / "lima.yaml"
        if not dest.exists(): return False

        old = yaml.dump(yaml.safe_load(dest.read_text()), sort_keys=True)
        new = yaml.dump(self._build_config_data(), sort_keys=True)
        if old == new: return False

        print(f"\n\033[1m[!] Configuration changes detected for '{self.vm_name}':\033[0m\n")
        for line in difflib.unified_diff(old.splitlines(), new.splitlines(), fromfile='Current', tofile='New', lineterm=''):
            color = "\033[32m" if line.startswith('+') and not line.startswith('+++') else \
                    "\033[31m" if line.startswith('-') and not line.startswith('---') else "\033[0m"
            print(f"{color}{line}\033[0m")

        if input("\nApply changes? (Requires restart) [y/N] ").lower() == 'y':
            dest.write_text(new)
            return True
        return False

    # --- CLI Actions ---

    def status(self):
        self._run(["limactl", "list", self.vm_name])

    def shell(self, *extra_args):
        """Opens an interactive shell inside the VM or runs a command."""
        workdir = f"/srv/www/{self.conf['key']}/current"
        cmd = ["limactl", "shell", "--workdir", workdir, self.vm_name]
        if extra_args:
            cmd.extend(extra_args)
        self._run(cmd, check=False)

    def url(self):
        print(f"http://{self.conf['canonical']}")

    def hosts(self):
        """Checks /etc/hosts for correct entries."""
        try: current = Path("/etc/hosts").read_text()
        except Exception: return

        missing = [h for h in self.conf['hosts']
                   if not re.search(rf"^{re.escape(self.conf['ip'])}\s+.*\b{re.escape(h)}\b", current, re.MULTILINE)]

        if missing:
            print(f"\n\033[93m[!] Missing /etc/hosts entries. Please run:\033[0m")
            for h in missing:
                print(f"  echo '{self.conf['ip']} {h}' | sudo tee -a /etc/hosts")
            print("")
        else:
             if len(sys.argv) > 1 and sys.argv[1] == 'hosts':
                 print(f"✓ Hosts file entries correct for IP {self.conf['ip']}")

    def stop(self):
        if self._get_status() == "Running":
            self._run(["limactl", "stop", self.vm_name], check=False)
        else:
            print(f"VM '{self.vm_name}' is not running.")

    def delete(self, force=False):
        if not force:
            if input(f"Delete '{self.vm_name}'? [y/N] ").lower() != 'y': return

        cmd = ["limactl", "delete", self.vm_name]
        if force: cmd.append("--force")
        self._run(cmd, check=not force)

        if PROVISION_MARKER.exists(): PROVISION_MARKER.unlink()

    def start(self):
        """Starts the VM, ensuring network is ready and config is up to date."""
        # 1. Pre-flight Network Checks (Linux only)
        if sys.platform == "linux":
            sysctl_path = "/proc/sys/net/ipv4/ip_unprivileged_port_start"
            if os.path.exists(sysctl_path):
                with open(sysctl_path, 'r') as f:
                    try:
                        if int(f.read().strip()) > 80:
                            print("\n\033[93m[!] Error: Privileged port access blocked.\033[0m")
                            print("  Run: echo 'net.ipv4.ip_unprivileged_port_start=80' | sudo tee /etc/sysctl.d/50-lima-ports.conf && sudo sysctl --system\n")
                            sys.exit(1)
                    except ValueError: pass

            res = subprocess.run(['ip', 'addr', 'show', 'dev', 'lo'], capture_output=True, text=True)
            if self.conf['ip'] not in res.stdout:
                print(f"\n\033[93m[!] Error: Host IP {self.conf['ip']} not found on 'lo' interface.\033[0m")
                print(f"  Run: sudo ip addr add {self.conf['ip']}/32 dev lo\n")
                sys.exit(1)

        # 2. Check Status & Reconcile Config
        status = self._get_status()

        if status is not None:
            # Existing VM: Check for config drift
            if self._reconcile_config():
                print("✓ Configuration updated.")
                if status == "Running":
                    print("Restarting VM to apply changes...")
                    self.stop()
                    status = "Stopped"

            if status == "Running":
                if sys.argv[1] == 'start':
                    print(f"VM '{self.vm_name}' is already running.")
                    self._check_provision_status()
                return

            print(f"Starting existing VM '{self.vm_name}'...")
            self._run(["limactl", "start", self.vm_name])
            self.hosts()
            if sys.argv[1] == 'start': self._check_provision_status()
            return

        # 3. Create New VM
        print(f"Creating and starting {self.vm_name}...")
        cfg = self._build_config_data()

        with tempfile.NamedTemporaryFile('w', suffix='.yaml', delete=False) as tmp:
            yaml.dump(cfg, tmp)
            tmp_path = tmp.name

        try:
            self._run(["limactl", "start", tmp_path, "--tty=false", "--name", self.vm_name])
        finally:
            Path(tmp_path).unlink(missing_ok=True)

        self.hosts()
        if sys.argv[1] == 'start': self._check_provision_status()

    def restart(self):
        self.stop()
        self.start()

    def provision(self, *extra_args):
        # Implicitly start (and update config) if needed
        self.start()

        ssh = self._get_ssh()
        if not ssh['port']: sys.exit("Error: Could not determine SSH port (VM running?)")

        h_file = TRELLIS_DIR / "hosts" / "development"
        if h_file.exists():
            h_file.write_text(re.sub(r"^[0-9.]+", self.conf['ip'], h_file.read_text(), flags=re.M))

        cmd = [
            "ansible-playbook", "dev.yml",
            "-e", f"ansible_port={ssh['port']}",
            "-e", "ansible_host=127.0.0.1",
            "-e", f"ansible_user={ssh['user']}",
            "-e", f"ansible_ssh_private_key_file={ssh['key']}",
            "-e", f"web_user={ssh['user']}",
            "-e", f"web_group={ssh['user']}"
        ]

        if extra_args:
            cmd.extend(extra_args)

        env = os.environ.copy()
        env['ANSIBLE_HOST_KEY_CHECKING'] = "False"
        print("Provisioning...")
        self._run(cmd, env=env)

        PROVISION_MARKER.parent.mkdir(parents=True, exist_ok=True)
        PROVISION_MARKER.touch()

    def init(self):
        """Ensures the VM is running and provisioned."""
        self.start()

        if not PROVISION_MARKER.exists():
            print("Server not provisioned. Running provision...")
            self.provision()
        else:
            print("✓ System already initialized and provisioned.")

    def rebuild(self):
        """Wipes the VM and rebuilds it from scratch."""
        if self._get_status() is not None:
            if input(f"Are you sure you want to DELETE and rebuild '{self.vm_name}'? [y/N] ").lower() != 'y':
                return
            self.delete(force=True)
        self.start()
        self.provision()

# --- Entry Point ---

def main():
    import inspect
    manager = TrellisLima()
    valid_cmds = [m for m in dir(manager) if not m.startswith('_') and callable(getattr(manager, m))]

    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("command", choices=valid_cmds, help="Command to run")
    args, extra_args = parser.parse_known_args()

    method = getattr(manager, args.command)
    sig = inspect.signature(method)

    if len(sig.parameters) > 0:
        method(*extra_args)
    else:
        if extra_args:
             print(f"\n\033[93m[!] Warning: Command '{args.command}' does not accept extra arguments: {' '.join(extra_args)}\033[0m\n")
        method()

if __name__ == "__main__":
    main()
